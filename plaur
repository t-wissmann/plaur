#!/usr/bin/env python3
# vim: et ts=4 sw=4
# Python 3

import subprocess
import configparser
import os
import sys
import re
import subprocess
import queue
import time

import pyalpm
import pycman
#from pycman import config
#from pycman import action_deptest

plaur_ini = "plaur.ini" # filename of the central plaur configuration file

class UserErrorMessage(Exception):
    def __init__(self, message):
        self.message = message
    def __str__(self):
        return self.message
    def print(self):
        print("%s error: %s" % (program_name, self.message))

class PackageUnverified(Exception):
    def __init__(self, path):
        self.path = path
    def __str(self):
        return "Package %s not verified" % self.path

def debug(*objs):
    #print("Debug: ", *objs, file=sys.stderr)
    return True

def error_msg(*objs):
    print("Error: ", *objs, file=sys.stderr)

class SRCINFO:
    # parse a .SRCINFO file and provide some wrapper functions
    def __init__(self, filepath):
        self.filepath = filepath
        # sections is a dictionary that maps pairs (e.g. ("pkgname","plaur")) to
        # section dictionaries. Each section dictionary maps keys to a list of
        # values
        # TODO: keep the order of sections fix if their order matters in the
        #       .SRCINFO specification
        self.sections = { }
        self.loaded_once = False

    def load(self):
        if not self.loaded_once:
            self.reload()
            self.loaded_once = True

    def reload(self):
        self.sections = { }
        try:
            with open(self.filepath, 'r') as f:
                lines = f.readlines()
        except FileNotFoundError as e:
            raise UserErrorMessage(str(e))
        is_emptyline = re.compile('^[ \\t]*(#.*)?$')
        is_header = re.compile('^(?P<name>[^= \\t]+) = (?P<value>.*)$')
        is_option = re.compile('^\t(?P<name>[^= \\t]+) = (?P<value>.*)$')
        current_section = { }
        current_header = None
        class Holder(object):
            def set(self, v):
                self.v = v
                return v
            def get(self):
                return self.v
        h = Holder()
        for i, line in enumerate(lines):
            line = line.rstrip('\r\n')
            if (is_emptyline.match(line)):
                #print("%d SKIP %s" % (i,line))
                continue
            elif h.set(is_header.match(line)):
                #print("%d header %s" %(i,line))
                if current_header != None:
                    self.sections[current_header] = current_section
                current_header = (h.get().group('name'),h.get().group('value'))
                current_section = { }
            elif h.set(is_option.match(line)):
                name = h.get().group('name')
                if not name in current_section:
                    current_section[name] = [ ]
                current_section[name].append(h.get().group('value'))
            else:
                raise UserErrorMessage("Line %d: unrecognized syntax: \"%s\"" % (i+1, line))
        # save the last section
        if current_header != None:
            self.sections[current_header] = current_section
        #print(self.sections)
    # example usage:
    # SRCINFO('.SRCINFO').reload()

    def __str__(self):
        buf = ""
        for (sectype,secname),section in self.sections.items():
            buf += "%s = %s\n" % (sectype,secname)
            for key,values in section.items():
                for v in values:
                    buf += "\t%s = %s\n" % (key,v)
            buf += "\n"
        return buf

    def packages(self):
        for sectype,secname in self.sections:
            if sectype == "pkgname":
                yield secname

    def query_pkgname(self,pkgname,key):
        # TODO: look up the precise semantics of .SRCINFO
        value = []
        fallback_value = []
        for (sectype,secname),options in self.sections.items():
            if sectype == "pkgname" and secname == pkgname:
                if key in options:
                    value += options[key]
            if sectype == "pkgbase":
                if key in options:
                    fallback_value += options[key]
        if value == []:
            value = fallback_value
        return value

    def package_names(self):
        class PackageName:
            def __init__(self,name,ver,rel,arch):
                self.name = name
                self.ver = ver
                self.rel = rel
                self.arch = arch
                self.suffix = '.pkg.tar.xz'
            def __str__(self):
                pattern = [self.name, self.ver, self.rel, self.arch]
                return '-'.join(pattern) + self.suffix
        res = [ ]
        for name in self.packages():
            ver = self.query_pkgname(name,'pkgver')[0]
            rel = self.query_pkgname(name,'pkgrel')[0]
            arches = self.query_pkgname(name,'arch')
            default_arch = 'x86_64'
            arch = 'any' if 'any' in arches else default_arch
            res.append(PackageName(name,ver,rel,arch))
        return res

    def query_any(self,key):
        value = []
        for (sectype,secname),options in self.sections.items():
            if key in options:
                value += options[key]
        return value

    @staticmethod
    def drop_version_constraints(deplist):
        """From a list of dependencies, drop all the versioning constraints,
        resulting in a traversable object of package names
        """
        only_name = re.compile('^[^<>=]*')
        for i in deplist:
            yield only_name.search(i).group(0)


# from http://stackoverflow.com/questions/566746/how-to-get-console-window-width-in-python
def getTerminalSize():
    import os
    env = os.environ
    def ioctl_GWINSZ(fd):
        try:
            import fcntl, termios, struct, os
            cr = struct.unpack('hh', fcntl.ioctl(fd, termios.TIOCGWINSZ,
        '1234'))
        except:
            return
        return cr
    cr = ioctl_GWINSZ(0) or ioctl_GWINSZ(1) or ioctl_GWINSZ(2)
    if not cr:
        try:
            fd = os.open(os.ctermid(), os.O_RDONLY)
            cr = ioctl_GWINSZ(fd)
            os.close(fd)
        except:
            pass
    if not cr:
        cr = (env.get('LINES', 25), env.get('COLUMNS', 80))

        ### Use get(key[, default]) instead of a try/catch
        #try:
        #    cr = (env['LINES'], env['COLUMNS'])
        #except:
        #    cr = (25, 80)
    return int(cr[1]), int(cr[0])

class ProgressBar:
    def __init__(self, progress = 0.0):
        self.progress = progress

    def set(self,progress):
        self.progress = progress
        self.redraw()

    def redraw(self):
        string = "\033[s\033[0;0H"
        (width, _) = getTerminalSize()
        width = width - 2
        for i in range(0, width):
            tick = int(self.progress * width)
            if i == tick:
                string += '|'
            elif i < tick:
                string += '='
            else:
                string += '.'
        string += '\033[0;0H\n\033[u'
        print(string, end="", flush=True)

# thanks to http://stackoverflow.com/questions/510357/python-read-a-single-character-from-the-user
class _GetchUnix:
    def __init__(self):
        import tty, sys

    def __call__(self):
        import sys, tty, termios
        fd = sys.stdin.fileno()
        old_settings = termios.tcgetattr(fd)
        try:
            tty.setraw(sys.stdin.fileno())
            ch = sys.stdin.read(1)
        finally:
            termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)
        return ch

def ask(message,default_yes=True):
    if default_yes:
        answers = '[Y/n]'
    else:
        answers = '[y/N]'
    print("%s %s " % (message,answers),end="",flush=True)
    ch = _GetchUnix()()
    if not ch == '\n':
        print(ch,flush=True)
    if ch.lower() == 'y':
        return True
    elif ch.lower() == 'n':
        return False
    else:
        return default_yes

def colored_header(message):
    return ("\033[0;33m========\033[1;37m %s \033[0;33m========\033[0m\n" % message)

#--------------- git wrapper  ---------------
class Git:
    # create a wrapper objects to access the git repository
    # whose git root is at path
    def __init__(self, path):
        self.git_dir = path + "/.git"
        self.git_work_tree = path

    # call a git command without redirecting stderr or stdout
    def plain_call(self, *args):
        git_prefix = [ 'git',
                       '--work-tree=' + self.git_work_tree,
                       '--git-dir=' + self.git_dir,
        ]
        command = git_prefix + list(args)
        debug("Calling »%s«" % ' '.join(command))
        proc = subprocess.Popen(command)
        return proc.wait()

    # call a git subcommand, returning a tuple:
    # stdout,stderr,status
    def call(self, *args):
        git_prefix = [ 'git',
                       '--work-tree=' + self.git_work_tree,
                       '--git-dir=' + self.git_dir,
        ]
        command = git_prefix + list(args)
        debug("Calling »%s«" % ' '.join(command))
        proc = subprocess.Popen(command,
                                stdout=subprocess.PIPE,
                                stderr=subprocess.PIPE)
        status = proc.wait()
        stdout = proc.stdout.read().decode("utf-8")
        stderr = proc.stderr.read().decode("utf-8")
        return stdout, stderr, status

    # call a successful, i.e. raise an UserErrorMessage
    # if the command exists with a status other than 0.
    # returns stdout as a string
    def call_success(self, *args):
        out,err,status = self.call(*args)
        if status != 0:
            err = re.sub("[\r\n]*$", "", err)
            cmd = ' '.join(list(args))
            if err == '':
                raise UserErrorMessage("git %s failed with status %d." % (cmd, status))
            else:
                raise UserErrorMessage("git %s failed with status %s: %s" %
                                        (cmd, status, err))
        if err != '':
            # just pass stderr
            print("git: %s" % err, file=sys.stderr)
        return out

    # tells wether a certain file is tracked by git
    # filepath can either be absolute or relative to the CWD
    def is_tracked(self, filepath):
        _,_,status = self.call('ls-files', '--error-unmatch', filepath);
        return (status == 0);

    # tells whether the git is a plaur repository
    def is_plaur_repo(self):
        pf = os.path.join(self.git_work_tree, plaur_ini)
        return self.is_tracked(pf);

    # returns the CWD relative to the root of the working tree
    def prefix_of_cwd(self):
        return self.call_success('rev-parse', '--show-prefix').strip()

    # returns the absolute path of the working dir
    def work_tree(self):
        return self.git_work_tree

    # tells whether the git exists in the file system
    def exists(self):
        return os.path.isdir(self.git_work_tree) and os.path.isdir(self.git_dir)

    # exit with an error message if the git directory does not exist
    def assert_exists(self):
        if not os.path.isdir(self.git_dir):
            raise UserErrorMessage("Git directory %s does not exist" % self.git_dir)
        if not os.path.isdir(self.git_work_tree):
            raise UserErrorMessage("Git work tree %s does not exist" % self.git_work_tree)

    def HEAD(self):
        return self.call_success('rev-parse', 'HEAD').strip()

# return the absolute path of the git root for the current working directory
# without trailing slashes, or None, if cwd does not live in a git repository
def detect_git(cwd='.'):
    cmd = ['git', 'rev-parse', '--show-toplevel']
    proc = subprocess.Popen(cmd,
                            stdout=subprocess.PIPE,
                            stderr=subprocess.PIPE,
                            cwd=cwd)
    status = proc.wait()
    stdout = proc.stdout.read().decode("utf-8")
    stderr = proc.stderr.read().decode("utf-8")
    if status == 0 and stderr == '':
        return re.sub('[/\r\n]*$', '', stdout)
    else:
        return None;

# returns a Git object for the plaur repository
def assert_plaur_git():
    gitpath = detect_git();
    if gitpath == None:
        raise UserErrorMessage("Not in a plaur git repository")
    git = Git(gitpath)
    if not git.is_plaur_repo():
        # if this detected git is not a plaur repository,
        # then maybe it's just a pkgbuild repo, so try the parent directory as
        # well:
        (gitpath,_) = os.path.split(gitpath.rstrip('/'))
        gitpath = detect_git(cwd=gitpath)
        if gitpath == None:
            raise UserErrorMessage("Not in a plaur git repository")
        git = Git(gitpath)
        if not git.is_plaur_repo():
            raise UserErrorMessage("Present directory is not in a plaur repository")
    #print(gitpath)
    global config
    config.set_filename_from_git(git)
    return git

#--------------- classes  ---------------
class Command:
    def __init__(self, callback, description, is_alias=False):
        self.callback = callback
        self.description = description
        self.is_alias = is_alias

class PlaurConfig:
    def __init__(self,filename = None):
        self.file = configparser.ConfigParser()
        self.file.add_section('options')
        self.filename = filename
        self.defaults = {
            # the defaults dictionary maps keys to pairs of default values and
            # some description
            'packages_file': ("packages.ini",
                  "file path to packages config, relative to the plaur git root"),
        }
    def set_filename_from_git(self, git):
        global plaur_ini
        self.filename = os.path.join(git.git_work_tree, plaur_ini)
        self.read()

    # this function should return a read-only reference...
    def __getitem__(self,key):
        if key in self.file['options']:
            return self.file['options']['key']
        elif key in self.defaults:
            (v,_) = self.defaults[key]
            return v
        else:
            return None

    def read(self):
        self.file.read(self.filename)
    def write(self):
        with open(self.filename, 'w') as configfile:
            self.file.write(configfile)
            configfile.close()
    def print_contents(self):
        print("Available options:")
        for (k,(_,d)) in self.defaults.items():
            print("%s: %s" % (k,d))
        print("\nDefault values:")
        for (k,(v,_)) in self.defaults.items():
            print("%s = %s" % (k,v))
        print("\nContents of " + str(self.filename) + ":")
        for s in self.file.sections():
            print("[%s]" % s)
            for k,v in self.file.items(s):
                print("%s = %s" % (k,v))

class PackageConfig:
    # git is a Git object representing the main plaur repository
    def __init__(self, git):
        self.config = configparser.ConfigParser()
        self.git = git
        self.package_objects = {}

    def add(self, path, url, asdeps=False):
        # TODO: check that path is prefix-free to all the other paths
        self.config[path] = {
            'url' : url,
            'verified' : "",
            'asdeps' : asdeps,
        }
    def absolute_filepath(self):
        return os.path.join(self.git.work_tree(), config['packages_file'])
    def read(self):
        self.config.read(self.absolute_filepath())
    def write(self):
        with open(self.absolute_filepath(), 'w') as configfile:
            self.config.write(configfile)
            configfile.close()
    def query(self, path):
        return self.config[path]
    def paths(self):
        names = list(self.config.keys())
        names.remove('DEFAULT')
        return names

    def get_package(self,path):
        path = os.path.normpath(path)
        if not path in self.config:
            raise UserErrorMessage("Invalid package path »%s«" % path)
        elif path in self.package_objects:
            return self.package_objects[path]
        else:
            obj = Package(self,path)
            self.package_objects[path] = obj
            return obj

    def fetch(self, path):
        self.get_package(path).fetch()

    def __getitem__(self,key):
        return self.get_package(key)

    # commit the packages file (and all other staged changes) to the git
    def commit(self, message):
        self.git.call_success("add", self.absolute_filepath())
        self.git.call_success('commit', '-m', message);

    def compute_depgraph(self,paths,provide_guessing = False):
        # provide-guessing: assume that each directory provides a package with
        # the same name. (This only applies if the .SRCINFO does not exist)
        # for the following computation, only paths specified in the paths
        # parameter are considered.
        # this method returns a pair of dictionaries:
        # a dictionary that maps dependencies to the list of paths
        # which require that dependency
        dependencies = { }
        # similarly, a dictionary that maps package name to the list of
        # paths which provide that package name
        provides = { }
        for fullpath in paths:
            package = self[fullpath]
            try:
                for i in package.dependencies():
                    dependencies.setdefault(i,[]).append(package.path)
                for i in package.provides():
                    provides.setdefault(i,[]).append(package.path)
            except FileNotFoundError as e:
                debug("Can not open .SRCINFO of %s: %s" % (package.path, str(e)))
                if provide_guessing:
                    i = os.path.basename(package.path)
                    print("Guessing that %s provides %s" % (package.path, i))
                    provides.setdefault(i,[]).append(package.path)
        return (dependencies,provides)

    @staticmethod
    def depsort(dependencies,provides):
        # map dependencies/provides dicts as given in the compute_depgraph()
        # function to a concrete order of the involved paths.
        # for a path, it tells how many other paths need to be built before.
        in_degree = { }
        ready_to_build = queue.Queue() # paths that can be built immediately
        # if a multiple paths P1 and P2 both provide the same package required
        # by some other path B, then both P1 and P2 are built before B is.
        path_provides = { } # map paths to packages it provides
        for package,provided_by in provides.items():
            for path in provided_by:
                # path provides package
                in_degree[path] = 0;
                path_provides.setdefault(path, []).append(package)
        for dep,required_by in dependencies.items():
            for path in required_by:
                in_degree.setdefault(path, 0)
                in_degree[path] += len(provides.get(dep, []))
        for path,degree in in_degree.items():
            if degree == 0:
                ready_to_build.put(path)
        topsorted = [ ]
        while not ready_to_build.empty():
            path = ready_to_build.get(block = False)
            topsorted.append(path)
            for provs in path_provides[path]:
                for next_path in dependencies.get(provs, []):
                    in_degree[next_path] -= 1;
                    assert(in_degree[next_path] >= 0)
                    if (in_degree[next_path] <= 0):
                        ready_to_build.put(next_path)
        cyclic_deps = []
        for path,degree in in_degree.items():
            if degree > 0:
                cyclic_deps.append(path)
        if cyclic_deps:
            msg = "Ignoring packages because of cyclic dependencies: "
            msg += ' '.join(cyclic_deps)
            error_msg(msg)
        return topsorted

    @staticmethod
    def test_depsort():
        dependencies = {
            'libpurple' : [ 'someprotocolpath' ],
            'pidgin' : [ 'someprotocolpath' ],
            'glib' : [ 'fullpidgin' ],
        }
        provides = {
            'libpurple' : ['onlylibpurple', 'fullpidgin'],
            'pidgin' : [ 'fullpidgin'],
            'someprotocol' : [ 'someprotocolpath' ],
        }
        print (' '.join(PackageConfig.depsort(dependencies, provides)))
        dependencies = {
            'n1' : [ 'p1' ],
            'n2' : [ 'p1' ],
            'n3' : [ ],
        }
        provides = {
            'n1' : ['px', 'p2'],
            'n2' : [ 'fullpidgin'],
            'n3' : [ 'someprotocolpath', 'p1' ],
        }
        print (' '.join(PackageConfig.depsort(dependencies, provides)))

class Package:
    # Package represents a concrete section of a PackageConfig
    def __init__(self, pacconf, path):
        # link to parent PackageConfig
        self.pacconf = pacconf
        self.path = path # path relative to plaur-repo
        if not self.path in self.pacconf.config:
            raise UserErrorMessage("Invalid package path »%s«" % path)
        self.settings = self.pacconf.config[self.path]
        self.fullpath = self.pacconf.git.work_tree() + "/" + self.path # absolute filepath
        self.git = Git(self.fullpath)
        self.srcinfo = SRCINFO(self.fullpath + '/.SRCINFO')

    def fetch(self):
        if not os.path.isdir(self.fullpath):
            url = self.settings['url']
            # FIXME: package_git.call_success("clone", url) somehow ignores the --git-dir
            if 0 != subprocess.call(["git", "clone", url, self.fullpath]):
                raise UserErrorMessage("git clone failed for %s" % self.path)
        else:
            self.git.call_success("pull", "--ff-only")

    def last_verified(self):
        last_verified = self.settings['verified']
        if last_verified == '':
            last_verified = '4b825dc642cb6eb9a060e54bf8d69288fbee4904'
        return last_verified

    def assert_verified(self):
        """If not verified, raise a PackageUnverified exception"""
        self.git.assert_exists()
        if self.last_verified() != self.git.HEAD():
            raise PackageUnverified(self.path)

    def dependencies(self):
        """Return a traversable of package names this package depends on"""
        self.srcinfo.load()
        deps = self.srcinfo.query_any('makedepends')
        deps += self.srcinfo.query_any('depends')
        deps += self.srcinfo.query_any('checkdepends')
        return SRCINFO.drop_version_constraints(deps)

    def provides(self):
        """Return a traversable of package names this package provides on"""
        self.srcinfo.load()
        provs = list(self.srcinfo.packages())
        provs += self.srcinfo.query_any('provides')
        return SRCINFO.drop_version_constraints(provs)
    def packagelist(self):
        """If .SRCINFO exists, return a list of packages"""
        self.srcinfo.load()
        return self.srcinfo.package_names()

    def is_built(self):
        """Tell whether all packages created by that package exist """
        for f in self.packagelist():
            f = os.path.join(self.fullpath, str(f))
            if not os.path.isfile(f):
                return False
        return True

    def uninstalled_packages(self):
        """Tell which packages by this package are not installed"""
        alpm = ALPM.get()
        local_db = alpm.get_localdb()
        uninstalled = [ ]
        for f in self.packagelist():
            dep = f.name + '=' + f.ver + '-' + f.rel
            if pyalpm.find_satisfier(local_db.pkgcache, dep):
                continue
            else:
                uninstalled.append(f)
        return uninstalled

    def build(self):
        self.assert_verified()
        print("  Running makepkg in %s" % self.path)
        makepkg = ['makepkg']
        makepkg += [ ]
        logfile = 'build-%s.log' % time.strftime('%Y-%m-%d-%H-%M')
        logfile = os.path.join(self.fullpath, logfile)
        with open(logfile, "w") as outfile:
            proc = subprocess.Popen(makepkg, cwd=self.fullpath, stdout=outfile, stderr=outfile)
        print("For live logging, type: tail -f %s" % logfile)
        status = proc.wait()

    @staticmethod
    def install(packagelist):
        asexplicit = [ ]
        asdeps = [ ]
        for package in packagelist:
            for f in package.packagelist():
                f = os.path.join(package.fullpath, str(f))
                if package.settings.getboolean('asdeps', fallback=False):
                    asdeps.append(f)
                else:
                    asexplicit.append(f)
        if not asexplicit and not asdeps:
            # nothing to install
            return
        pacman = [ 'sudo', 'pacman', '-U' ]
        pacman += asexplicit
        pacman += asdeps
        proc = subprocess.Popen(pacman)
        status = proc.wait()
        if asexplicit:
            pacman = [ 'sudo', 'pacman', '-D', '--asexplicit' ]
            pacman += asexplicit
            proc = subprocess.Popen(pacman)
            status = proc.wait()
        if asdeps:
            pacman = [ 'sudo', 'pacman', '-D', '--asdeps' ]
            pacman += asdeps
            proc = subprocess.Popen(pacman)
            status = proc.wait()


#--------------- commands ---------------
def find_command(name):
    global commands_dict
    if name in commands_dict:
        return commands_dict[name]
    else:
        raise UserErrorMessage("No such subcommand »%s«" % name)

def cmd_usage(args):
    """Usage: help [CMD]

    Print the long description of the specified subcommand CMD.
    If no CMD is given, list all the available subcommands.
    """
    if len(args) == 0:
        print("Usage: %s SUBCOMMANDS [ARGS...]" % program_name)
        print("where SUBCOMMANDS is one of the following:")
        print("")
        for name,cmd in commands:
            print("    %-10s%s" % (name,cmd.description))
    else:
        c = find_command(args[0])
        print(program_name + " " + args[0] + ": " + c.description)
        if c.callback.__doc__ != None:
            print()
            print(c.callback.__doc__.lstrip("\n "))

def cmd_init(args):
    """Usage: init

    Initialize an empty plaur repository in the current working directory"""
    git_path = detect_git();
    if git_path != None:
        raise UserErrorMessage("Already a git repository in »%s«" % git_path)
    git = Git(os.getcwd())
    out = git.call_success('init');
    global config
    config.set_filename_from_git(git)
    config.read()
    config.write()
    git.call_success("add", config.filename)
    # create empty packages file
    p = PackageConfig(git)
    p.read()
    p.write()
    git.call_success("add", p.absolute_filepath())
    git.call_success("commit", "-m", "Initial commit");

def cmd_fetch(args):
    """Usage: fetch [PATH…]

    Updates the given PATHs to the current upstream version, and creates them
    if necessary.

    If no PATH is given, then all configured paths will be fetched.
    """
    paths = args
    git = assert_plaur_git()
    packs = PackageConfig(git);
    packs.read();
    prefix = git.prefix_of_cwd()
    if paths:
        # prepend a prefix to paths, depending on the cwd
        paths = [ prefix + p for p in paths ]
    else:
        # if no path is given, implicitly use all paths saved
        paths = packs.paths()
    draw_progressbar = True
    #pg = ProgressBar()
    #pg.set(0.0)
    for i,p in enumerate(paths):
        #pg.set(float(i) / len(paths))
        print("Fetching %s" % p)
        packs.fetch(p)
    #pg.set(1.0)

def cmd_add(args):
    """Usage: add [--asdeps] PACKAGENAME [PATH]

    Add a package with name PACKAGENAME and put it in the directory specified
    by PATH (either absolute or relative to the current working directory).
    PATH defaults to PACKAGENAME.

    If --asdeps is supplied, then the package will be marked as being a
    dependency for another package.
    """
    asdeps = False
    if (len(args) >= 1 and args[0] == '--asdeps'):
        asdeps = True
        args = args[1:]
    if (len(args) < 1):
        raise UserErrorMessage("To few arguments")
    name = args[0]
    path = args[1] if len(args) > 1 else name
    git = assert_plaur_git()
    packs = PackageConfig(git)
    prefix = git.prefix_of_cwd()
    packs.read()
    packs.add(prefix+path, "https://aur.archlinux.org/%s.git" % name, asdeps = asdeps)
    packs.write()
    packs.commit("Add " + prefix + path);

def cmd_diff(args):
    """Usage: diff [PATH…]

    For the given PATHs, print the differences between the last verified
    and the current version.

    If no PATH is specified, then the difference of all paths with changes will
    be shown.
    """
    git = assert_plaur_git()
    packs = PackageConfig(git)
    packs.read()
    prefix = git.prefix_of_cwd()
    # TODO: use $PAGER
    pager = subprocess.Popen(['less', '-i', '-R', '-K', '-X', '--quit-if-one-screen'],
                            stdin=subprocess.PIPE,
                            )
    paths = args
    hide_if_unchanged = False
    if paths:
        # prepend a prefix to paths, depending on the cwd
        paths = [ prefix + p for p in paths ]
    else:
        # if no path is given, implicitly use all paths saved
        paths = packs.paths()
        hide_if_unchanged = True
    for fullpath in paths:
        package = packs[fullpath]
        last_verified = package.last_verified()
        diff_string = package.git.call_success('diff', '--color=always', last_verified, 'HEAD')
        if hide_if_unchanged and diff_string.lstrip() == '':
            continue
        output  = colored_header(package.path)
        output += diff_string
        output += "\n"
        pager.stdin.write(output.encode("utf-8"))
        pager.stdin.flush()
    pager.stdin.close()
    pager.wait()

def cmd_verify(args):
    """Usage: verify [PATH…]

    For the given PATHs, mark the current version as verified.
    This means, that the PKGBUILD (and the attached files) in them can be
    sourced and executed.

    If no PATH is specified, then all paths are verified interactively.
    """
    git = assert_plaur_git()
    packs = PackageConfig(git)
    packs.read()
    prefix = git.prefix_of_cwd()
    user_confirm = False
    show_diffs = False # this makes only sense if user_confirm is set to True
    paths = args
    if paths:
        # prepend a prefix to paths, depending on the cwd
        paths = [ prefix + p for p in paths ]
    else:
        # if no path is given, implicitly use all paths saved
        paths = packs.paths()
        user_confirm = True
        show_diffs = True
    for fullpath in paths:
        package = packs[fullpath]
        package.git.assert_exists()
        package_HEAD = package.git.HEAD();
        last_verified = package.last_verified()
        if last_verified == package_HEAD:
            print("%s up to date (on %s)." % (package.path, last_verified))
            continue
        if show_diffs:
            print(colored_header("Changes in " + package.path))
            print(package.git.call_success('diff', '--color=always', last_verified, 'HEAD'))
        if not user_confirm or ask("Verify %s to %s?" % (package.path, package_HEAD),default_yes=False):
            print ("Verifying %s to %s." % (package.path, package_HEAD))
            package.settings['verified'] = package_HEAD
            packs.write()
            packs.commit("Verify " + package.path)

def cmd_build(args):
    """Usage: build [--install] [PATH…]

    Execute makepkg in those of the given PATHs, that are verified, and skip
    the other (unverified) PATHs.

    If --install is passed, then the built packages are installed directly.
    """
    install = False
    if (len(args) >= 1 and args[0] == '--install'):
        install = True
        args = args[1:]
    git = assert_plaur_git()
    packs = PackageConfig(git)
    packs.read()
    paths = args
    if paths:
        # prepend a prefix to paths, depending on the cwd
        prefix = git.prefix_of_cwd()
        paths = [ prefix + p for p in paths ]
    else:
        paths = packs.paths()
        install = True
    # reorder paths according to dependencies
    (provides,dependencies) = packs.compute_depgraph(paths, provide_guessing = True)
    paths = PackageConfig.depsort(provides,dependencies)
    print("Building the packages: " + ' '.join(paths))
    for fullpath in paths:
        package = packs[fullpath]
        try:
            if not package.is_built():
                package.build()
            else:
                print("Not building up to date %s" % package.path)
            if package.uninstalled_packages():
                Package.install([package])
            else:
                print("Not installing up to date %s" % package.path)
        except PackageUnverified as e:
            print("Skipping unverified %s" % e.path)

def cmd_git(args):
    """Usage: git [ARGS…]

    Execute some git command in the main plaur repository.

    This allows performing git commands on the plaur repo without leaving the
    current working directory. This is convenient, because often one is in a
    subdirectory which is a git repository of a PKGBUILD.
    """
    git = assert_plaur_git()
    sys.exit(git.plain_call(*args))

def cmd_asciidoc(args):
    global commands_dict
    flag = re.compile('(?P<flag>--[\w-]+)')
    argname = re.compile('(?P<argname>[A-Z][A-Z0-9…]+[a-z]*)')
    print("""%s(1)
=======
:doctype: manpage


NAME
----
%s - a pleasant AUR helper using the power of git


SYNOPSIS
--------
*plaur* 'SUBCOMMAND' ['ARGS'…]


DESCRIPTION
-----------
Calls the given *plaur* subcommand. The meanings of the arguments 'ARGS' depend
on the 'SUBCOMMAND'. The available commands and their meanings are described in
the <<COMMANDS,*COMMANDS*>> section.

include::plaur_concept.txt[]

[[COMMANDS]]
COMMANDS
--------
""" % (program_name, program_name) )
    for name,c in sorted(commands_dict.items()):
        if c.is_alias:
            # avoid multiple entries due to command aliases
            continue
        # extract the usage line:
        if c.callback.__doc__ == None:
            description = ""
        else:
            description = c.callback.__doc__.strip('\n ')
        description = flag.sub(r'*\1*', description)
        description = argname.sub(r"'\1'", description)
        usage_rest = description.split('\n', 1)
        if len(usage_rest) == 0 or usage_rest[0] == '':
            usage = name
            longdesc = ""
        elif len(usage_rest) == 1:
            usage = usage_rest[0]
            longdesc = ""
        else:
            usage = usage_rest[0]
            longdesc = usage_rest[1]
        if usage.startswith("Usage: "):
            usage = usage[len("Usage: "):]
        print ('\n' + usage + '::')
        print ('    __' + c.description + '__')
        print (re.compile('^$', re.MULTILINE).sub(r'    +', longdesc))
    print("""
[[FILES]]
FILES
-----
Beside the actual packages *plaur* manages two files, as described in the
following. Both are using the <<INIFILEFORMAT,*INI FILE FORMAT*>>.

[[MAINCONFIGURATION]]
MAIN CONFIGURATION: plaur.ini
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
The git root of the plaur repository must contain a file named +plaur.ini+
serving two purposes. Firstly it identifies a git repository as a plaur
repository. Secondly it contains the user specific configuration. Its content
is never written by *plaur* and is intended to be edited manually by the user
if needed. The available options are available in the only file section called
+options+:

""")
    for (k,(v,d)) in config.defaults.items():
        print("'%s' (Default value: +%s+)::\n  %s" % (k,v,d))

    print("""

[[PACKAGESCONFIGURATION]]
PACKAGES CONFIGURATION: packages.ini
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
In the git root, a file +packages.ini+ (file name and location are configurable
in +plaur.ini+) lists the packages and their options, managed by *plaur*. It is
edited automatically via *plaur* and not intended to be written by the user.

[[INIFILEFORMAT]]
INI FILE FORMAT
~~~~~~~~~~~~~~~
All configuration files are of python's ini format:

    - Lines beginning with +#+ are treated as commetns
    - The file is divided into sections. Each section starts with a line
      +[name]+ where +name+ denotes the section name. Then multiple lines
      of the pattern +key = value+ follow.

RESOURCES
---------
Github page: http://github.com/t-wissmann/plaur
""")

def cmd_status(args):
    class Cell:
        def __init__(self,text,color=None):
            self.text = text
            self.color = color
        def width(self):
            # TODO: return utf8 string length
            return 2+len(self.text)
        def render(self,width):
            string = (" %-"+str(width-2)+"s ") % self.text
            if self.color:
                string = "\033[%sm%s\033[0m" % (self.color,string)
            return string
    class Table:
        def __init__(self):
            self.rows = [ ]
        def add_row(self,r):
            self.rows.append(r);
        def __str__(self):
            # firstly, construct the width of the columns
            colwidths = [ ]
            for r in self.rows:
                for i,c in enumerate(r):
                    if len(colwidths) <= i:
                        colwidths.append(c.width())
                    else:
                        colwidths[i] = max(colwidths[i], c.width())
            # secondly, print the table
            buf = ""
            for r in self.rows:
                for i,c in enumerate(r):
                    buf += c.render(colwidths[i])
                buf += "\n"
            return buf

    git = assert_plaur_git()
    packs = PackageConfig(git)
    packs.read()
    paths = args
    if paths:
        # prepend a prefix to paths, depending on the cwd
        prefix = git.prefix_of_cwd()
        paths = [ prefix + p for p in paths ]
    else:
        # if no path is given, implicitly use all paths saved
        paths = packs.paths()
    table = Table()
    hashlength = 10 # tells how short the git commit hashes are cropped
    for fullpath in paths:
        package = packs[fullpath]
        last_verified = package.last_verified()
        lvcolor = '42;30'
        headcolor = None
        if package.git.exists():
            head = package.git.HEAD()
            if head == last_verified:
                headcolor = lvcolor
            else:
                headcolor = '41;1;37'
        else:
            head = ''
        r = [
            Cell(fullpath),
            Cell(last_verified[0:hashlength],color=lvcolor),
            Cell(head[0:hashlength],color=headcolor),
        ]
        table.add_row(r)
    print(table,end="")

class ALPM:
    pacman_config = None
    alpm_handle = None
    @staticmethod
    def get():
        if ALPM.alpm_handle == None:
            ALPM.pacman_config = pycman.config.PacmanConfig(conf = '/etc/pacman.conf')
            ALPM.alpm_handle = ALPM.pacman_config.initialize_alpm()
        return ALPM.alpm_handle

def alpm_depcheck(packages):
    # check the availability of the package names 'packages'
    # in the packman repository and return three (not necessarily disjoint!)
    # lists of package names of the following form:
    class DepCheckResult:
        def __init__(self):
            # Each of them is a list of required packages ...
            # ... that are installable via a (non-ignored) repository:
            self.repoinstall = [ ]
            # ... that are present in an ignored repository:
            self.repoignore = [ ]
            # ... that are not found in any pacman/alpm repository
            self.missing = [ ]
            # ... that are already installed
            self.installed = [ ]
        def __str__(self):
            sep = ', '
            return """repoinstall = %s
repoignore  = %s
missing     = %s
installed   = %s""" % (sep.join(self.repoinstall), sep.join(self.repoignore), sep.join(self.missing), sep.join(self.installed))
    res = DepCheckResult()
    alpm = ALPM.get()
    local_db = alpm.get_localdb()
    dbs = alpm.get_syncdbs()
    repo_ignore_re = re.compile("thorsten")
    for dep in packages:
        is_installed = False
        if pyalpm.find_satisfier(local_db.pkgcache, dep):
            res.installed.append(dep)
            is_installed = True
        repo_found = False
        for db in dbs:
            match = repo_ignore_re.match(db.name)
            if match and match.end() == len(db.name) and db.get_pkg(dep):
                res.repoignore.append(dep)
                continue
            pkg = pyalpm.find_satisfier(db.pkgcache, dep)
            if pkg is not None:
                #print("%s is in repo %s" % (dep,db.name))
                repo_found = True
            if pkg is not None and not is_installed:
                # mark that it still needs to be installed
                res.repoinstall.append(dep)
        if not repo_found:
            #print("%s missing" % dep)
            res.missing.append(dep)
    return res

def cmd_depadd(args):
    """Usage: depadd [PATHs…]

    This command is still under development. Right now, it just prints all the
    dependencies for the given PATHs.
    """
    git = assert_plaur_git()
    prefix = git.prefix_of_cwd()
    packs = PackageConfig(git)
    packs.read()
    paths = args
    if paths:
        # prepend a prefix to paths, depending on the cwd
        paths = [ prefix + p for p in paths ]
    else:
        # if no path is given, implicitly use all paths saved
        paths = packs.paths()
    (dependencies,provides) = packs.compute_depgraph(paths,provide_guessing=False)
    unresolved_deps = [ ]
    for needed,by in dependencies.items():
        if not needed in provides:
            unresolved_deps.append(needed)
    print("unresolved: %s" % ' '.join(unresolved_deps))
    res = alpm_depcheck(unresolved_deps)
    print(res)
    pacman_command = 'sudo pacman -S --asdeps'.split(' ')
    print("Packages in ignored repositories: " + ' '.join(res.repoignore))
    print("Packages installable: " + ' '.join(res.repoinstall))
    if res.repoinstall and ask ("Install above packages via '%s'?" % ' '.join(pacman_command)):
        proc = subprocess.Popen(pacman_command + res.repoinstall)
        proc.wait()
    print("Unresolved: %s" % ' '.join(res.missing))
    if res.missing and ask ("Add unresolved packages?"):
        packs.read()
        for p in res.missing:
            path = os.path.join(prefix, p)
            url = "https://aur.archlinux.org/%s.git" % p
            packs.add(path, url, asdeps = True)
            packs.write()
            msg = ("Add dependency %s\n\n"
                + "It is required by:\n"
                + "  - %s\n") % (path, '\n  - '.join(dependencies[p]))
            #print(msg)
            packs.commit(msg)


def cmd_cat_srcinfo(args):
    """
    Usage: cat_srcinfo [FILES…]

    This command exists solely for debugging purposes:

    Read the supplied FILES of the .SRCINFO format and print them again.
    The order of options may change, however the order of different options
    with the same key stays unchanged.
    """
    for f in args:
        srcinfo = SRCINFO(f)
        srcinfo.load()
        print(srcinfo, end="")

def cmd_cat_config(args):
    """
    Usage: cat_config

    This command exists solely for debugging purposes:

    Show the contents of the plaur.ini of the present plaur repository.
    """
    assert_plaur_git()
    config.print_contents()

def cmd_why(args):
    """
    Usage: why [PACKAGES…]

    For the given PACKAGES, why they are in the plaur repository. That is, tell
    whether it was added explicitly or as a dependency, and tell by which other
    packages it is needed.
    """
    git = assert_plaur_git()
    packs = PackageConfig(git)
    packs.read()
    (deps,provs) = packs.compute_depgraph(packs.paths())
    paths = args
    if paths:
        prefix = git.prefix_of_cwd()
        paths = [ os.path.join(prefix, p) for p in paths ]
    else:
        paths = packs.paths()
    for package in [ packs[p] for p in paths ]:
        if package.settings.getboolean('asdeps', fallback=False):
            print("%s was added as a dependency." % package.path)
        else:
            print("%s was added explicitly." % package.path)
        for name,provided_by in provs.items():
            if package.path in provided_by:
                msg = "  %s required by: " % name
                l = deps.get(name, [])
                msg += ' '.join(l) if l else "nothing else"
                print(msg)



#---------------   main   ---------------
commands = [
    [ "-h",      Command(cmd_usage, "Print this help", is_alias=True)],
    [ "--help",  Command(cmd_usage, "Print this help", is_alias=True)],
    [ "help",    Command(cmd_usage, "Print general help or that of a subcommand")],
    [ "init",    Command(cmd_init, "Initalize the present directory")],
    [ "add",     Command(cmd_add, "Add a new package")],
    [ "fetch",   Command(cmd_fetch, "Update or create a PKGBUILD from upstream")],
    [ "diff",    Command(cmd_diff, "Show differences since last verification")],
    [ "verify",  Command(cmd_verify, "Verify a pkgbuild")],
    [ "build",   Command(cmd_build, "Build the specified packages")],
    [ "git",     Command(cmd_git, "Run a git command on the packages repository")],
    [ "asciidoc",Command(cmd_asciidoc, "Generate documentation in asciidoc format")],
    [ "status",  Command(cmd_status, "Show package version and build status")],
    [ "st",      Command(cmd_status, "Show package version and build status", is_alias=True)],
    [ "depadd",  Command(cmd_depadd, "Add dependencies for the given packages")],
    [ "cat_srcinfo",  Command(cmd_cat_srcinfo, "Read and print the given .SRCINFO files")],
    [ "cat_config",  Command(cmd_cat_config, "Read and print the plaur.ini")],
    [ "why",  Command(cmd_why, "Tell why a package is in the plaur repository")],
]
commands_dict = { }
for k,v in commands:
    commands_dict[k] = v
program_name = re.sub('^.*/', '', sys.argv[0])
config = PlaurConfig()

if len(sys.argv) <= 1:
    cmd_usage([])
else:
    try:
        c = find_command(sys.argv[1])
        c.callback(sys.argv[2:])
    except UserErrorMessage as e:
        e.print()
        sys.exit(1)
