#!/usr/bin/env python3
# vim: et ts=4 sw=4
# Python 3

import subprocess
import configparser
import os
import sys
import re
import subprocess

#--------------- config ---------------
# some file paths, all relative to the git root directory:
packages_file = "packages.ini" # file path to packages config

class UserErrorMessage(Exception):
    def __init__(self, message):
        self.message = message
    def __str__(self):
        return self.message
    def print(self):
        print("%s error: %s" % (program_name, self.message))

def debug(*objs):
    #print("Debug: ", *objs, file=sys.stderr)
    return True

class SRCINFO:
    # parse a .SRCINFO file and provide some wrapper functions
    def __init__(self, filepath):
        self.filepath = filepath
        self.reload
        self.sections = { }

    def reload(self):
        self.sections = { }
        f = open(self.filepath, 'r')
        lines = f.readlines()
        f.close()
        is_emptyline = re.compile('^[ \\t]*(#.*)?$')
        is_header = re.compile('^(?P<name>[^= \\t]+) = (?P<value>.*)$')
        is_option = re.compile('^\t(?P<name>[^= \\t]+) = (?P<value>.*)$')
        current_section = { }
        current_header = None
        class Holder(object):
            def set(self, v):
                self.v = v
                return v
            def get(self):
                return self.v
        h = Holder()
        for i, line in enumerate(lines):
            line = line.rstrip('\r\n')
            if (is_emptyline.match(line)):
                #print("%d SKIP %s" % (i,line))
                continue
            elif h.set(is_header.match(line)):
                #print("%d header %s" %(i,line))
                if current_header != None:
                    self.sections[current_header] = current_section
                current_header = (h.get().group('name'),h.get().group('value'))
                current_section = { }
            elif h.set(is_option.match(line)):
                current_section[h.get().group('name')] = h.get().group('value')
            else:
                raise UserErrorMessage("Line %d: unrecognized syntax: \"%s\"" % (i+1, line))
        # save the last section
        if current_header != None:
            self.sections[current_header] = current_section
        #print(self.sections)
    # example usage:
    # SRCINFO('.SRCINFO').reload()

    def packages(self):
        for sectype,secname in self.sections:
            if sectype == "pkgname":
                yield secname

    def query_option(self,pkgname,key):
        value = []
        fallback_value = []
        for (sectype,secname),options in self.sections.items():
            if sectype == "pkgname" and secname == pkgname:
                if key in options:
                    value += [ options[key] ]
            if sectype == "pkgbase":
                if key in options:
                    fallback_value += [ options[key] ]
        if value == []:
            value = fallback_value
        return value

# from http://stackoverflow.com/questions/566746/how-to-get-console-window-width-in-python
def getTerminalSize():
    import os
    env = os.environ
    def ioctl_GWINSZ(fd):
        try:
            import fcntl, termios, struct, os
            cr = struct.unpack('hh', fcntl.ioctl(fd, termios.TIOCGWINSZ,
        '1234'))
        except:
            return
        return cr
    cr = ioctl_GWINSZ(0) or ioctl_GWINSZ(1) or ioctl_GWINSZ(2)
    if not cr:
        try:
            fd = os.open(os.ctermid(), os.O_RDONLY)
            cr = ioctl_GWINSZ(fd)
            os.close(fd)
        except:
            pass
    if not cr:
        cr = (env.get('LINES', 25), env.get('COLUMNS', 80))

        ### Use get(key[, default]) instead of a try/catch
        #try:
        #    cr = (env['LINES'], env['COLUMNS'])
        #except:
        #    cr = (25, 80)
    return int(cr[1]), int(cr[0])

class ProgressBar:
    def __init__(self, progress = 0.0):
        self.progress = progress

    def set(self,progress):
        self.progress = progress
        self.redraw()

    def redraw(self):
        string = "\033[s\033[0;0H"
        (width, _) = getTerminalSize()
        width = width - 2
        for i in range(0, width):
            tick = int(self.progress * width)
            if i == tick:
                string += '|'
            elif i < tick:
                string += '='
            else:
                string += '.'
        string += '\033[0;0H\n\033[u'
        print(string, end="", flush=True)

# thanks to http://stackoverflow.com/questions/510357/python-read-a-single-character-from-the-user
class _GetchUnix:
    def __init__(self):
        import tty, sys

    def __call__(self):
        import sys, tty, termios
        fd = sys.stdin.fileno()
        old_settings = termios.tcgetattr(fd)
        try:
            tty.setraw(sys.stdin.fileno())
            ch = sys.stdin.read(1)
        finally:
            termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)
        return ch

def ask(message,default_yes=True):
    if default_yes:
        answers = '[Yn]'
    else:
        answers = '[yN]'
    print("%s %s " % (message,answers),end="",flush=True)
    ch = _GetchUnix()()
    if not ch == '\n':
        print(ch,flush=True)
    if ch.lower() == 'y':
        return True
    elif ch.lower() == 'n':
        return False
    else:
        return default_yes

def colored_header(message):
    return ("\033[0;33m========\033[1;37m %s \033[0;33m========\033[0m\n" % message)

#--------------- git wrapper  ---------------
class Git:
    # create a wrapper objects to access the git repository
    # whose git root is at path
    def __init__(self, path):
        self.git_dir = path + "/.git"
        self.git_work_tree = path

    # call a git command without redirecting stderr or stdout
    def plain_call(self, *args):
        git_prefix = [ 'git',
                       '--work-tree=' + self.git_work_tree,
                       '--git-dir=' + self.git_dir,
        ]
        command = git_prefix + list(args)
        debug("Calling »%s«" % ' '.join(command))
        proc = subprocess.Popen(command)
        return proc.wait()

    # call a git subcommand, returning a tuple:
    # stdout,stderr,status
    def call(self, *args):
        git_prefix = [ 'git',
                       '--work-tree=' + self.git_work_tree,
                       '--git-dir=' + self.git_dir,
        ]
        command = git_prefix + list(args)
        debug("Calling »%s«" % ' '.join(command))
        proc = subprocess.Popen(command,
                                stdout=subprocess.PIPE,
                                stderr=subprocess.PIPE)
        status = proc.wait()
        stdout = proc.stdout.read().decode("utf-8")
        stderr = proc.stderr.read().decode("utf-8")
        return stdout, stderr, status

    # call a successful, i.e. raise an UserErrorMessage
    # if the command exists with a status other than 0.
    # returns stdout as a string
    def call_success(self, *args):
        out,err,status = self.call(*args)
        if status != 0:
            err = re.sub("[\r\n]*$", "", err)
            cmd = ' '.join(list(args))
            if err == '':
                raise UserErrorMessage("git %s failed with status %d." % (cmd, status))
            else:
                raise UserErrorMessage("git %s failed with status %s: %s" %
                                        (cmd, status, err))
        if err != '':
            # just pass stderr
            print("git: %s" % err, file=sys.stderr)
        return out

    # tells wether a certain file is tracked by git
    # filepath can either be absolute or relative to the CWD
    def is_tracked(self, filepath):
        _,_,status = self.call('ls-files', '--error-unmatch', filepath);
        return (status == 0);

    # tells whether the git is a plaur repository
    def is_plaur_repo(self):
        return self.is_tracked(self.git_work_tree + "/" + packages_file);

    # returns the CWD relative to the root of the working tree
    def prefix_of_cwd(self):
        return self.call_success('rev-parse', '--show-prefix').strip()

    # returns the absolute path of the working dir
    def work_tree(self):
        return self.git_work_tree

    # tells whether the git exists in the file system
    def exists(self):
        return os.path.isdir(self.git_work_tree) and os.path.isdir(self.git_dir)

    # exit with an error message if the git directory does not exist
    def assert_exists(self):
        if not os.path.isdir(self.git_dir):
            raise UserErrorMessage("Git directory %s does not exist" % self.git_dir)
        if not os.path.isdir(self.git_work_tree):
            raise UserErrorMessage("Git work tree %s does not exist" % self.git_work_tree)

    def HEAD(self):
        return self.call_success('rev-parse', 'HEAD').strip()

# return the absolute path of the git root for the current working directory
# without trailing slashes, or None, if cwd does not live in a git repository
def detect_git(cwd='.'):
    cmd = ['git', 'rev-parse', '--show-toplevel']
    proc = subprocess.Popen(cmd,
                            stdout=subprocess.PIPE,
                            stderr=subprocess.PIPE,
                            cwd=cwd)
    status = proc.wait()
    stdout = proc.stdout.read().decode("utf-8")
    stderr = proc.stderr.read().decode("utf-8")
    if status == 0 and stderr == '':
        return re.sub('[/\r\n]*$', '', stdout)
    else:
        return None;

# returns a Git object for the plaur repository
def assert_plaur_git():
    gitpath = detect_git();
    if gitpath == None:
        raise UserErrorMessage("Not in a plaur git repository")
    git = Git(gitpath)
    if not git.is_plaur_repo():
        # if this detected git is not a plaur repository,
        # then maybe it's just a pkgbuild repo, so try the parent directory as
        # well:
        (gitpath,_) = os.path.split(gitpath.rstrip('/'))
        gitpath = detect_git(cwd=gitpath)
        if gitpath == None:
            raise UserErrorMessage("Not in a plaur git repository")
        git = Git(gitpath)
        if not git.is_plaur_repo():
            raise UserErrorMessage("Present directory is not in a plaur repository")
    #print(gitpath)
    return git

#--------------- classes  ---------------
class Command:
    def __init__(self, callback, description, is_alias=False):
        self.callback = callback
        self.description = description
        self.is_alias = is_alias

class PackageConfig:
    # git is a Git object representing the main plaur repository
    def __init__(self, git):
        self.config = configparser.ConfigParser()
        self.git = git
        self.package_objects = {}

    def add(self, path, url, asdeps=False):
        # TODO: check that path is prefix-free to all the other paths
        self.config[path] = {
            'url' : url,
            'verified' : "",
            'asdeps' : asdeps,
        }
    def read(self):
        self.config.read(self.git.work_tree() + "/" + packages_file)
    def write(self):
        with open(self.git.work_tree() + "/" + packages_file, 'w') as configfile:
            self.config.write(configfile)
            configfile.close()
    def query(self, path):
        return self.config[path]
    def paths(self):
        names = list(self.config.keys())
        names.remove('DEFAULT')
        return names

    def get_package(self,path):
        path = os.path.normpath(path)
        if not path in self.config:
            raise UserErrorMessage("Invalid package path »%s«" % path)
        elif path in self.package_objects:
            return self.package_objects[path]
        else:
            obj = Package(self,path)
            self.package_objects[path] = obj
            return obj

    def fetch(self, path):
        self.get_package(path).fetch()

    def __getitem__(self,key):
        return self.get_package(key)

    # commit the packages file (and all other staged changes) to the git
    def commit(self, message):
        self.git.call_success("add", self.git.work_tree() + "/" + packages_file)
        self.git.call_success('commit', '-m', message);

class Package:
    # Package represents a concrete section of a PackageConfig
    def __init__(self, pacconf, path):
        # link to parent PackageConfig
        self.pacconf = pacconf
        self.path = path # path relative to plaur-repo
        if not self.path in self.pacconf.config:
            raise UserErrorMessage("Invalid package path »%s«" % path)
        self.settings = self.pacconf.config[self.path]
        self.fullpath = self.pacconf.git.work_tree() + "/" + self.path # absolute filepath
        self.git = Git(self.fullpath)

    def fetch(self):
        if not os.path.isdir(self.fullpath):
            url = self.settings['url']
            # FIXME: package_git.call_success("clone", url) somehow ignores the --git-dir
            if 0 != subprocess.call(["git", "clone", url, self.fullpath]):
                raise UserErrorMessage("git clone failed for %s" % self.path)
        else:
            self.git.call_success("pull", "--ff-only")

    def last_verified(self):
        last_verified = self.settings['verified']
        if last_verified == '':
            last_verified = '4b825dc642cb6eb9a060e54bf8d69288fbee4904'
        return last_verified

#--------------- commands ---------------
def find_command(name):
    global commands_dict
    if name in commands_dict:
        return commands_dict[name]
    else:
        raise UserErrorMessage("No such subcommand »%s«" % name)

def cmd_usage(args):
    """Usage: help [CMD]

    Print the long description of the specified subcommand CMD.
    If no CMD is given, list all the available subcommands.
    """
    if len(args) == 0:
        print("Usage: %s SUBCOMMANDS [ARGS...]" % program_name)
        print("where SUBCOMMANDS is one of the following:")
        print("")
        for name,cmd in commands:
            print("    %-10s%s" % (name,cmd.description))
    else:
        c = find_command(args[0])
        print(program_name + " " + args[0] + ": " + c.description)
        if c.callback.__doc__ != None:
            print()
            print(c.callback.__doc__)

def cmd_init(args):
    """Usage: init

    Initialize an empty plaur repository in the current working directory"""
    git_path = detect_git();
    if git_path != None:
        raise UserErrorMessage("Already a git repository in »%s«" % git_path)
    git = Git(os.getcwd())
    out = git.call_success('init');
    # create empty packages file
    p = PackageConfig(git)
    p.read()
    p.write()
    global packages_file
    git.call_success("add", git.work_tree() + "/" + packages_file)
    git.call_success("commit", "-m", "Initialize empty %s" % packages_file);

def cmd_fetch(args):
    """Usage: fetch [PATH…]

    Updates the given PATHs to the current upstream version, and creates them
    if necessary.

    If no PATH is given, then all configured paths will be fetched.
    """
    paths = args
    git = assert_plaur_git()
    packs = PackageConfig(git);
    packs.read();
    prefix = git.prefix_of_cwd()
    if paths:
        # prepend a prefix to paths, depending on the cwd
        paths = [ prefix + p for p in paths ]
    else:
        # if no path is given, implicitly use all paths saved
        paths = packs.paths()
    draw_progressbar = True
    #pg = ProgressBar()
    #pg.set(0.0)
    for i,p in enumerate(paths):
        #pg.set(float(i) / len(paths))
        print("Fetching %s" % p)
        packs.fetch(p)
    #pg.set(1.0)

def cmd_add(args):
    """Usage: add [--asdeps] PACKAGENAME [PATH]

    Add a package with name PACKAGENAME and put it in the directory specified
    by PATH (either absolute or relative to the current working directory).
    PATH defaults to PACKAGENAME.

    If --asdeps is supplied, then the package will be marked as being a
    dependency for another package.
    """
    asdeps = False
    if (len(args) >= 1 and args[0] == '--asdeps'):
        asdeps = True
        args = args[1:]
    if (len(args) < 1):
        raise UserErrorMessage("To few arguments")
    name = args[0]
    path = args[1] if len(args) > 1 else name
    git = assert_plaur_git()
    packs = PackageConfig(git)
    prefix = git.prefix_of_cwd()
    packs.read()
    packs.add(prefix + path, "https://aur.archlinux.org/%s.git" % name, asdeps)
    packs.write()
    packs.commit("Add " + prefix + path);

def cmd_diff(args):
    """Usage: diff [PATH…]

    For the given PATHs, print the differences between the last verified
    and the current version.

    If no PATH is specified, then the difference of all paths with changes will
    be shown.
    """
    git = assert_plaur_git()
    packs = PackageConfig(git)
    packs.read()
    prefix = git.prefix_of_cwd()
    # TODO: use $PAGER
    pager = subprocess.Popen(['less', '-i', '-R', '-K', '-X', '--quit-if-one-screen'],
                            stdin=subprocess.PIPE,
                            )
    paths = args
    hide_if_unchanged = False
    if paths:
        # prepend a prefix to paths, depending on the cwd
        paths = [ prefix + p for p in paths ]
    else:
        # if no path is given, implicitly use all paths saved
        paths = packs.paths()
        hide_if_unchanged = True
    for fullpath in paths:
        package = packs[fullpath]
        last_verified = package.last_verified()
        diff_string = package.git.call_success('diff', '--color=always', last_verified, 'HEAD')
        if hide_if_unchanged and diff_string.lstrip() == '':
            continue
        output  = colored_header(package.path)
        output += diff_string
        output += "\n"
        pager.stdin.write(output.encode("utf-8"))
        pager.stdin.flush()
    pager.stdin.close()
    pager.wait()

def cmd_verify(args):
    """Usage: verify [PATH…]

    For the given PATHs, mark the current version as verified.
    This means, that the PKGBUILD (and the attached files) in them can be
    sourced and executed.

    If no PATH is specified, then all paths are verified interactively.
    """
    git = assert_plaur_git()
    packs = PackageConfig(git)
    packs.read()
    prefix = git.prefix_of_cwd()
    user_confirm = False
    show_diffs = False # this makes only sense if user_confirm is set to True
    paths = args
    if paths:
        # prepend a prefix to paths, depending on the cwd
        paths = [ prefix + p for p in paths ]
    else:
        # if no path is given, implicitly use all paths saved
        paths = packs.paths()
        user_confirm = True
        show_diffs = True
    for fullpath in paths:
        package = packs[fullpath]
        package.git.assert_exists()
        package_HEAD = package.git.HEAD();
        last_verified = package.last_verified()
        if last_verified == package_HEAD:
            print("%s up to date (on %s)." % (package.path, last_verified))
            continue
        if show_diffs:
            print(colored_header("Changes in " + package.path))
            print(package.git.call_success('diff', '--color=always', last_verified, 'HEAD'))
        if not user_confirm or ask("Verify %s to %s?" % (package.path, package_HEAD),default_yes=False):
            print ("Verifying %s to %s." % (package.path, package_HEAD))
            package.settings['verified'] = package_HEAD
            packs.write()
            packs.commit("Verify " + package.path)

def cmd_build(args):
    """Usage: build [--install] [PATH…]

    Execute makepkg in those of the given PATHs, that are verified, and skip
    the other (unverified) PATHs.

    If --install is passed, then the built packages are installed directly.
    """
    install = False
    if (len(args) >= 1 and args[0] == '--install'):
        install = True
        args = args[1:]
    git = assert_plaur_git()
    packs = PackageConfig(git)
    packs.read()
    prefix = git.prefix_of_cwd()
    for path in args:
        fullpath = prefix + path
        package = packs[fullpath]
        package.git.assert_exists()
        package_HEAD = package.git.HEAD()
        last_verified = package.last_verified()
        if package_HEAD == last_verified:
            print("Running makepkg in %s" % package.path)
            makepkg = ['makepkg']
            if install:
                makepkg += ['-i']
                if package.settings.getboolean('asdeps', fallback=False):
                    makepkg += ['--asdeps']
            proc = subprocess.Popen(makepkg,
                                    cwd=git.work_tree() + "/" + package.path,
                                    )
            status = proc.wait()
        else:
            print("Skipping unverified %s" % package.path)

def cmd_git(args):
    """Usage: git [ARGS…]

    Execute some git command in the main plaur repository.

    This allows performing git commands on the plaur repo without leaving the
    current working directory. This is convenient, because often one is in a
    subdirectory which is a git repository of a PKGBUILD.
    """
    git = assert_plaur_git()
    sys.exit(git.plain_call(*args))

def cmd_asciidoc(args):
    global commands_dict
    flag = re.compile('(?P<flag>--[\w-]+)')
    argname = re.compile('(?P<argname>[A-Z][A-Z0-9…]+[a-z]*)')
    print("""%s(1)
=======
:doctype: manpage


NAME
----
%s - a pleasant AUR helper using the power of git


SYNOPSIS
--------
*plaur* 'SUBCOMMAND' ['ARGS'…]


DESCRIPTION
-----------
Calls the given *plaur* subcommand. The meanings of the arguments 'ARGS' depend
on the 'SUBCOMMAND'. The available commands and their meanings are described in
the <<COMMANDS,*COMMANDS*>> section.

[[COMMANDS]]
COMMANDS
--------
""" % (program_name, program_name) )
    for name,c in sorted(commands_dict.items()):
        if c.is_alias:
            # avoid multiple entries due to command aliases
            continue
        # extract the usage line:
        if c.callback.__doc__ == None:
            description = ""
        else:
            description = c.callback.__doc__.rstrip('\n ')
        description = flag.sub(r'*\1*', description)
        description = argname.sub(r"'\1'", description)
        usage_rest = description.split('\n', 1)
        if len(usage_rest) == 0 or usage_rest[0] == '':
            usage = name
            longdesc = ""
        elif len(usage_rest) == 1:
            usage = usage_rest[0]
            longdesc = ""
        else:
            usage = usage_rest[0]
            longdesc = usage_rest[1]
        if usage.startswith("Usage: "):
            usage = usage[len("Usage: "):]
        print ('\n' + usage + '::')
        print ('    __' + c.description + '__')
        print (re.compile('^$', re.MULTILINE).sub(r'    +', longdesc))
    print("""
== RESOURCES
Github page: http://github.com/t-wissmann/plaur
""")

#---------------   main   ---------------
commands = [
    [ "-h",      Command(cmd_usage, "Print this help", is_alias=True)],
    [ "--help",  Command(cmd_usage, "Print this help", is_alias=True)],
    [ "help",    Command(cmd_usage, "Print general help or that of a subcommand")],
    [ "init",    Command(cmd_init, "Initalize the present directory")],
    [ "add",     Command(cmd_add, "Add a new package")],
    [ "fetch",   Command(cmd_fetch, "Update or create a PKGBUILD from upstream")],
    [ "diff",    Command(cmd_diff, "Show differences since last verification")],
    [ "verify",  Command(cmd_verify, "Verify a pkgbuild")],
    [ "build",   Command(cmd_build, "Build the specified packages")],
    [ "git",     Command(cmd_git, "Run a git command on the packages repository")],
    [ "asciidoc",Command(cmd_asciidoc, "Generate documentation in asciidoc format")],
]
commands_dict = { }
for k,v in commands:
    commands_dict[k] = v
program_name = re.sub('^.*/', '', sys.argv[0])

if len(sys.argv) <= 1:
    cmd_usage([])
else:
    try:
        c = find_command(sys.argv[1])
        c.callback(sys.argv[2:])
    except UserErrorMessage as e:
        e.print()
        sys.exit(1)
