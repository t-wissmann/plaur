#!/usr/bin/python
# vim: et ts=4 sw=4
# Python 3

import subprocess
import configparser
import os
import sys
import re
import subprocess

#--------------- config ---------------
# some file paths, all relative to the git root directory:
packages_file = "packages.ini" # file path to packages config

class UserErrorMessage(Exception):
    def __init__(self, message):
        self.message = message
    def __str__(self):
        return self.message

def debug(*objs):
    #print("Debug: ", *objs, file=sys.stderr)
    return True

#--------------- git wrapper  ---------------
class Git:
    # create a wrapper objects to access the git repository
    # whose git root is at path
    def __init__(self, path):
        self.git_dir = path + "/.git"
        self.git_work_tree = path

    # call a git subcommand, returning a tuple:
    # stdout,stderr,status
    def call(self, *args):
        git_prefix = [ 'git',
                       '--work-tree=' + self.git_work_tree,
                       '--git-dir=' + self.git_dir,
        ]
        command = git_prefix + list(args)
        debug("Calling »%s«" % ' '.join(command))
        proc = subprocess.Popen(command,
                                stdout=subprocess.PIPE,
                                stderr=subprocess.PIPE)
        status = proc.wait()
        stdout = proc.stdout.read().decode("utf-8")
        stderr = proc.stderr.read().decode("utf-8")
        return stdout, stderr, status

    # call a successful, i.e. raise an UserErrorMessage
    # if the command exists with a status other than 0.
    # returns stdout as a string
    def call_success(self, *args):
        out,err,status = self.call(*args)
        if status != 0:
            err = re.sub("[\r\n]*$", "", err)
            cmd = ' '.join(list(args))
            if err == '':
                raise UserErrorMessage("git %s failed with status %d." % (cmd, status))
            else:
                raise UserErrorMessage("git %s failed with status %s: %s" %
                                        (cmd, status, err))
        if err != '':
            # just pass stderr
            print("git: %s" % err, file=sys.stderr)
        return out

    # tells wether a certain file is tracked by git
    # filepath can either be absolute or relative to the CWD
    def is_tracked(self, filepath):
        _,_,status = self.call('ls-files', '--error-unmatch', filepath);
        return (status == 0);

    # tells whether the git is a plaur repository
    def is_plaur_repo(self):
        return self.is_tracked(self.git_work_tree + "/" + packages_file);

    # returns the CWD relative to the root of the working tree
    def prefix_of_cwd(self):
        return self.call_success('rev-parse', '--show-prefix').strip()

    # returns the absolute path of the working dir
    def work_tree(self):
        return self.git_work_tree

# return the absolute path of the git root for the current working directory
# without trailing slashes, or None, if cwd does not live in a git repository
def detect_git():
    cmd = ['git', 'rev-parse', '--show-toplevel']
    proc = subprocess.Popen(cmd,
                            stdout=subprocess.PIPE,
                            stderr=subprocess.PIPE)
    status = proc.wait()
    stdout = proc.stdout.read().decode("utf-8")
    stderr = proc.stderr.read().decode("utf-8")
    if status == 0 and stderr == '':
        return re.sub('[/\r\n]*$', '', stdout)
    else:
        return None;

# returns a Git object for the plaur repository
def assert_plaur_git():
    gitpath = detect_git();
    if gitpath == None:
        raise UserErrorMessage("Not in a plaur git repository")
    git = Git(gitpath)
    if not git.is_plaur_repo():
        raise UserErrorMessage("Present git repository in »%s« is not a plaur repository"
                               % git.work_tree())
    return git

#--------------- classes  ---------------
class Command:
    def __init__(self, callback, description):
        self.callback = callback
        self.description = description

class Packages:
    # git is a Git object representing the main plaur repository
    def __init__(self, git):
        self.config = configparser.ConfigParser()
        self.git = git
    def add(self, path, url):
        # TODO: check that path is prefix-free to all the other paths
        self.config[path] = {
            'url' : url,
            'verified' : "",
        }
    def read(self):
        self.config.read(self.git.work_tree() + "/" + packages_file)
    def write(self):
        with open(self.git.work_tree() + "/" + packages_file, 'w') as configfile:
            self.config.write(configfile)
            configfile.close()
    def query(self, path):
        return self.config[path]
    def fetch(self, path):
        if not path in self.config:
            raise UserErrorMessage("Invalid package path »%s«" % path)
        fullpath = self.git.work_tree() + "/" + path
        package_git = Git(fullpath)
        if not os.path.isdir(fullpath):
            url = self.config[path]['url']
            # FIXME: package_git.call_success("clone", url) somehow ignores the --git-dir
            if 0 != subprocess.call(["git", "clone", url, fullpath]):
                raise UserErrorMessage("git clone failed for %s" % path)
        else:
            package_git.call_success("pull", "--ff-only")

    # commit the packages file (and all other staged changes) to the git
    def commit(self, message):
        self.git.call_success("add", self.git.work_tree() + "/" + packages_file)
        self.git.call_success('commit', '-m', message);

#--------------- commands ---------------
def find_command(name):
    global commands_dict
    if name in commands_dict:
        return commands_dict[name]
    else:
        raise UserErrorMessage("No such subcommand »%s«" % name)

def cmd_usage(args):
    """Usage: help [CMD]

    Print the long description of the specified subcommand CMD.
    If no CMD is given, list all the available subcommands.
    """
    if len(args) == 0:
        print("Usage: %s SUBCOMMANDS [ARGS...]" % program_name)
        print("where SUBCOMMANDS is one of the following:")
        print("")
        for name,cmd in commands:
            print("    %-10s%s" % (name,cmd.description))
    else:
        c = find_command(args[0])
        print(program_name + " " + args[0] + ": " + c.description)
        print()
        print(c.callback.__doc__)

def cmd_init(args):
    """Initialize an empty plaur repository in the current working directory"""
    git_path = detect_git();
    if git_path != None:
        raise UserErrorMessage("Already a git repository in »%s«" % git_path)
    git = Git(os.getcwd())
    out = git.call_success('init');
    # create empty packages file
    p = Packages(git)
    p.read()
    p.write()
    global packages_file
    git.call_success("add", git.work_tree() + "/" + packages_file)
    git.call_success("commit", "-m", "Initialize empty %s" % packages_file);

def cmd_fetch(args):
    """Usage: fetch [PATH…]

    Updates the given PATHs to the current upstream version, and creates them
    if necessary.
    """
    paths = args
    git = assert_plaur_git()
    packs = Packages(git);
    packs.read();
    prefix = git.prefix_of_cwd()
    for p in paths:
        packs.fetch(prefix + p)

def cmd_add(args):
    """Usage: add PACKAGENAME [PATH]

    Add a package with name PACKAGENAME and put it in the directory specified
    by PATH (either absolute or relative to the current working directory).
    PATH defaults to PACKAGENAME.
    """
    if (len(args) < 1):
        raise UserErrorMessage("To few arguments")
    name = args[0]
    path = args[1] if len(args) > 1 else name
    git = assert_plaur_git()
    packs = Packages(git)
    prefix = git.prefix_of_cwd()
    packs.read()
    packs.add(prefix + path, "https://aur.archlinux.org/%s.git" % name)
    packs.write()
    packs.commit("Add " + prefix + path);

def cmd_diff(args):
    """Usage: diff [PATH…]

    For the given PATHs, print the differences between the last verified
    and the current version.
    """
    git = assert_plaur_git()
    packs = Packages(git)
    packs.read()
    prefix = git.prefix_of_cwd()
    # TODO: use $PAGER
    pager = subprocess.Popen(['less', '-i', '-R', '-K', '-X', '--quit-if-one-screen'],
                            stdin=subprocess.PIPE,
                            )
    for path in args:
        fullpath = prefix + path
        package = packs.query(fullpath)
        package_git = Git(git.work_tree() + "/" + fullpath)
        last_verified = package['verified']
        if last_verified == '':
            last_verified = '4b825dc642cb6eb9a060e54bf8d69288fbee4904'
        output  = "\033[0;33m========\033[1;37m %s \033[0;33m========\033[0m\n" % fullpath
        output += package_git.call_success('diff', '--color=always', last_verified, 'HEAD')
        output += "\n"
        pager.stdin.write(output.encode("utf-8"))
        pager.stdin.flush()
    pager.stdin.close()
    pager.wait()

def cmd_verify(args):
    """Usage: verify [PATH…]

    For the given PATHs, mark the current version as verified.
    This means, that the PKGBUILD (and the attached files) in them can be
    sourced and executed.
    """
    git = assert_plaur_git()
    packs = Packages(git)
    packs.read()
    prefix = git.prefix_of_cwd()
    for path in args:
        fullpath = prefix + path
        package = packs.query(fullpath)
        package_git = Git(git.work_tree() + "/" + fullpath)
        package_HEAD = package_git.call_success('rev-parse', 'HEAD').strip();
        print ("Verifying %s to %s." % (fullpath, package_HEAD))
        package['verified'] = package_HEAD
        packs.write()
        packs.commit("Verify " + fullpath)

#---------------   main   ---------------
commands = [
    [ "-h",      Command(cmd_usage, "Print this help")],
    [ "--help",  Command(cmd_usage, "Print this help")],
    [ "help",    Command(cmd_usage, "Print this help or that of a subcommand")],
    [ "init",    Command(cmd_init, "Initalize the present directory")],
    [ "add",     Command(cmd_add, "Add a new package")],
    [ "fetch",   Command(cmd_fetch, "Update or create a PKGBUILD from upstream")],
    [ "diff",    Command(cmd_diff, "Show differences since last verification")],
    [ "verify",  Command(cmd_verify, "Verify a pkgbuild")],
]
commands_dict = { }
for k,v in commands:
    commands_dict[k] = v
program_name = re.sub('^.*/', '', sys.argv[0])

if len(sys.argv) <= 1:
    cmd_usage([])
else:
    try:
        c = find_command(sys.argv[1])
        c.callback(sys.argv[2:])
    except UserErrorMessage as e:
        print("%s error: %s" % (program_name, e.message))
