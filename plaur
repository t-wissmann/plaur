#!/usr/bin/env python3
# vim: et ts=4 sw=4
# Python 3

import subprocess
import configparser
import os
import sys
import re
import subprocess

#--------------- config ---------------
# some file paths, all relative to the git root directory:
packages_file = "packages.ini" # file path to packages config

class UserErrorMessage(Exception):
    def __init__(self, message):
        self.message = message
    def __str__(self):
        return self.message
    def print(self):
        print("%s error: %s" % (program_name, self.message))

def debug(*objs):
    #print("Debug: ", *objs, file=sys.stderr)
    return True

# thanks to http://stackoverflow.com/questions/510357/python-read-a-single-character-from-the-user
class _GetchUnix:
    def __init__(self):
        import tty, sys

    def __call__(self):
        import sys, tty, termios
        fd = sys.stdin.fileno()
        old_settings = termios.tcgetattr(fd)
        try:
            tty.setraw(sys.stdin.fileno())
            ch = sys.stdin.read(1)
        finally:
            termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)
        return ch

def ask(message,default_yes=True):
    if default_yes:
        answers = '[Yn]'
    else:
        answers = '[yN]'
    print("%s %s " % (message,answers),end="",flush=True)
    ch = _GetchUnix()()
    if not ch == '\n':
        print(ch,flush=True)
    if ch.lower() == 'y':
        return True
    elif ch.lower() == 'n':
        return False
    else:
        return default_yes

def colored_header(message):
    return ("\033[0;33m========\033[1;37m %s \033[0;33m========\033[0m\n" % message)

#--------------- git wrapper  ---------------
class Git:
    # create a wrapper objects to access the git repository
    # whose git root is at path
    def __init__(self, path):
        self.git_dir = path + "/.git"
        self.git_work_tree = path

    # call a git subcommand, returning a tuple:
    # stdout,stderr,status
    def call(self, *args):
        git_prefix = [ 'git',
                       '--work-tree=' + self.git_work_tree,
                       '--git-dir=' + self.git_dir,
        ]
        command = git_prefix + list(args)
        debug("Calling »%s«" % ' '.join(command))
        proc = subprocess.Popen(command,
                                stdout=subprocess.PIPE,
                                stderr=subprocess.PIPE)
        status = proc.wait()
        stdout = proc.stdout.read().decode("utf-8")
        stderr = proc.stderr.read().decode("utf-8")
        return stdout, stderr, status

    # call a successful, i.e. raise an UserErrorMessage
    # if the command exists with a status other than 0.
    # returns stdout as a string
    def call_success(self, *args):
        out,err,status = self.call(*args)
        if status != 0:
            err = re.sub("[\r\n]*$", "", err)
            cmd = ' '.join(list(args))
            if err == '':
                raise UserErrorMessage("git %s failed with status %d." % (cmd, status))
            else:
                raise UserErrorMessage("git %s failed with status %s: %s" %
                                        (cmd, status, err))
        if err != '':
            # just pass stderr
            print("git: %s" % err, file=sys.stderr)
        return out

    # tells wether a certain file is tracked by git
    # filepath can either be absolute or relative to the CWD
    def is_tracked(self, filepath):
        _,_,status = self.call('ls-files', '--error-unmatch', filepath);
        return (status == 0);

    # tells whether the git is a plaur repository
    def is_plaur_repo(self):
        return self.is_tracked(self.git_work_tree + "/" + packages_file);

    # returns the CWD relative to the root of the working tree
    def prefix_of_cwd(self):
        return self.call_success('rev-parse', '--show-prefix').strip()

    # returns the absolute path of the working dir
    def work_tree(self):
        return self.git_work_tree

    # tells whether the git exists in the file system
    def exists(self):
        return os.path.isdir(self.git_work_tree) and os.path.isdir(self.git_dir)

    # exit with an error message if the git directory does not exist
    def assert_exists(self):
        if not os.path.isdir(self.git_dir):
            raise UserErrorMessage("Git directory %s does not exist" % self.git_dir)
        if not os.path.isdir(self.git_work_tree):
            raise UserErrorMessage("Git work tree %s does not exist" % self.git_work_tree)

# return the absolute path of the git root for the current working directory
# without trailing slashes, or None, if cwd does not live in a git repository
def detect_git():
    cmd = ['git', 'rev-parse', '--show-toplevel']
    proc = subprocess.Popen(cmd,
                            stdout=subprocess.PIPE,
                            stderr=subprocess.PIPE)
    status = proc.wait()
    stdout = proc.stdout.read().decode("utf-8")
    stderr = proc.stderr.read().decode("utf-8")
    if status == 0 and stderr == '':
        return re.sub('[/\r\n]*$', '', stdout)
    else:
        return None;

# returns a Git object for the plaur repository
def assert_plaur_git():
    gitpath = detect_git();
    if gitpath == None:
        raise UserErrorMessage("Not in a plaur git repository")
    git = Git(gitpath)
    if not git.is_plaur_repo():
        raise UserErrorMessage("Present git repository in »%s« is not a plaur repository"
                               % git.work_tree())
    return git

#--------------- classes  ---------------
class Command:
    def __init__(self, callback, description):
        self.callback = callback
        self.description = description

class Packages:
    # git is a Git object representing the main plaur repository
    def __init__(self, git):
        self.config = configparser.ConfigParser()
        self.git = git
    def add(self, path, url, asdeps=False):
        # TODO: check that path is prefix-free to all the other paths
        self.config[path] = {
            'url' : url,
            'verified' : "",
            'asdeps' : asdeps,
        }
    def read(self):
        self.config.read(self.git.work_tree() + "/" + packages_file)
    def write(self):
        with open(self.git.work_tree() + "/" + packages_file, 'w') as configfile:
            self.config.write(configfile)
            configfile.close()
    def query(self, path):
        return self.config[path]
    def paths(self):
        names = list(self.config.keys())
        names.remove('DEFAULT')
        return names
    def fetch(self, path):
        if not path in self.config:
            raise UserErrorMessage("Invalid package path »%s«" % path)
        fullpath = self.git.work_tree() + "/" + path
        package_git = Git(fullpath)
        if not os.path.isdir(fullpath):
            url = self.config[path]['url']
            # FIXME: package_git.call_success("clone", url) somehow ignores the --git-dir
            if 0 != subprocess.call(["git", "clone", url, fullpath]):
                raise UserErrorMessage("git clone failed for %s" % path)
        else:
            package_git.call_success("pull", "--ff-only")

    # commit the packages file (and all other staged changes) to the git
    def commit(self, message):
        self.git.call_success("add", self.git.work_tree() + "/" + packages_file)
        self.git.call_success('commit', '-m', message);

#--------------- commands ---------------
def find_command(name):
    global commands_dict
    if name in commands_dict:
        return commands_dict[name]
    else:
        raise UserErrorMessage("No such subcommand »%s«" % name)

def cmd_usage(args):
    """Usage: help [CMD]

    Print the long description of the specified subcommand CMD.
    If no CMD is given, list all the available subcommands.
    """
    if len(args) == 0:
        print("Usage: %s SUBCOMMANDS [ARGS...]" % program_name)
        print("where SUBCOMMANDS is one of the following:")
        print("")
        for name,cmd in commands:
            print("    %-10s%s" % (name,cmd.description))
    else:
        c = find_command(args[0])
        print(program_name + " " + args[0] + ": " + c.description)
        print()
        print(c.callback.__doc__)

def cmd_init(args):
    """Initialize an empty plaur repository in the current working directory"""
    git_path = detect_git();
    if git_path != None:
        raise UserErrorMessage("Already a git repository in »%s«" % git_path)
    git = Git(os.getcwd())
    out = git.call_success('init');
    # create empty packages file
    p = Packages(git)
    p.read()
    p.write()
    global packages_file
    git.call_success("add", git.work_tree() + "/" + packages_file)
    git.call_success("commit", "-m", "Initialize empty %s" % packages_file);

def cmd_fetch(args):
    """Usage: fetch [PATH…]

    Updates the given PATHs to the current upstream version, and creates them
    if necessary.

    If no PATH is given, then all configured paths will be fetched.
    """
    paths = args
    git = assert_plaur_git()
    packs = Packages(git);
    packs.read();
    prefix = git.prefix_of_cwd()
    if not paths:
        # if no path is given, implicitly use all paths saved
        paths = packs.paths()
    for p in paths:
        packs.fetch(prefix + p)

def cmd_add(args):
    """Usage: add [--asdeps] PACKAGENAME [PATH]

    Add a package with name PACKAGENAME and put it in the directory specified
    by PATH (either absolute or relative to the current working directory).
    PATH defaults to PACKAGENAME.

    If --asdeps is supplied, then the package will be marked as being a
    dependency for another package.
    """
    asdeps = False
    if (len(args) >= 1 and args[0] == '--asdeps'):
        asdeps = True
        args = args[1:]
    if (len(args) < 1):
        raise UserErrorMessage("To few arguments")
    name = args[0]
    path = args[1] if len(args) > 1 else name
    git = assert_plaur_git()
    packs = Packages(git)
    prefix = git.prefix_of_cwd()
    packs.read()
    packs.add(prefix + path, "https://aur.archlinux.org/%s.git" % name, asdeps)
    packs.write()
    packs.commit("Add " + prefix + path);

def cmd_diff(args):
    """Usage: diff [PATH…]

    For the given PATHs, print the differences between the last verified
    and the current version.

    If no PATH is specified, then the difference of all paths with changes will
    be shown.
    """
    git = assert_plaur_git()
    packs = Packages(git)
    packs.read()
    prefix = git.prefix_of_cwd()
    # TODO: use $PAGER
    pager = subprocess.Popen(['less', '-i', '-R', '-K', '-X', '--quit-if-one-screen'],
                            stdin=subprocess.PIPE,
                            )
    paths = args
    hide_if_unchanged = False
    if not paths:
        # if no path is given, implicitly use all paths saved
        paths = packs.paths()
        hide_if_unchanged = True
    for path in paths:
        fullpath = prefix + path
        package = packs.query(fullpath)
        package_git = Git(git.work_tree() + "/" + fullpath)
        last_verified = package['verified']
        if last_verified == '':
            last_verified = '4b825dc642cb6eb9a060e54bf8d69288fbee4904'
        diff_string = package_git.call_success('diff', '--color=always', last_verified, 'HEAD')
        if hide_if_unchanged and diff_string.lstrip() == '':
            continue
        output  = colored_header(fullpath)
        output += diff_string
        output += "\n"
        pager.stdin.write(output.encode("utf-8"))
        pager.stdin.flush()
    pager.stdin.close()
    pager.wait()

def cmd_verify(args):
    """Usage: verify [PATH…]

    For the given PATHs, mark the current version as verified.
    This means, that the PKGBUILD (and the attached files) in them can be
    sourced and executed.

    If no PATH is specified, then all paths are verified interactively.
    """
    git = assert_plaur_git()
    packs = Packages(git)
    packs.read()
    prefix = git.prefix_of_cwd()
    user_confirm = False
    show_diffs = False # this makes only sense if user_confirm is set to True
    paths = args
    if not paths:
        # if no path is given, implicitly use all paths saved
        paths = packs.paths()
        user_confirm = True
        show_diffs = True
    for path in paths:
        fullpath = prefix + path
        package = packs.query(fullpath)
        package_git = Git(git.work_tree() + "/" + fullpath)
        package_git.assert_exists()
        package_HEAD = package_git.call_success('rev-parse', 'HEAD').strip();
        last_verified = package['verified']
        if last_verified == '':
            last_verified = '4b825dc642cb6eb9a060e54bf8d69288fbee4904'
        if last_verified == package_HEAD:
            print("%s up to date (on %s)." % (fullpath, last_verified))
            continue
        if show_diffs:
            print(colored_header("Changes in " + fullpath))
            print(package_git.call_success('diff', '--color=always', last_verified, 'HEAD'))
        if not user_confirm or ask("Verify %s to %s?" % (fullpath, package_HEAD),default_yes=False):
            print ("Verifying %s to %s." % (fullpath, package_HEAD))
            package['verified'] = package_HEAD
            packs.write()
            packs.commit("Verify " + fullpath)

def cmd_build(args):
    """Usage: build [--install] [PATH…]

    Execute makepkg in those of the given PATHs, that are verified, and skip
    the other (unverified) PATHs.

    If --install is passed, then the built packages are installed directly.
    """
    install = False
    if (len(args) >= 1 and args[0] == '--install'):
        install = True
        args = args[1:]
    git = assert_plaur_git()
    packs = Packages(git)
    packs.read()
    prefix = git.prefix_of_cwd()
    for path in args:
        fullpath = prefix + path
        package = packs.query(fullpath)
        package_git = Git(git.work_tree() + "/" + fullpath)
        package_git.assert_exists()
        package_HEAD = package_git.call_success('rev-parse', 'HEAD').strip();
        last_verified = package['verified']
        if last_verified == '':
            last_verified = '4b825dc642cb6eb9a060e54bf8d69288fbee4904'
        last_verified = package_git.call_success('rev-parse', last_verified).strip();
        if package_HEAD == last_verified:
            print("Running makepkg in %s" % fullpath)
            makepkg = ['makepkg']
            if install:
                makepkg += ['-i']
                if packs.query(fullpath).getboolean('asdeps', fallback=False):
                    makepkg += ['--asdeps']
            proc = subprocess.Popen(makepkg,
                                    cwd=git.work_tree() + "/" + fullpath,
                                    )
            status = proc.wait()
        else:
            print("Skipping unverified %s" % fullpath)


#---------------   main   ---------------
commands = [
    [ "-h",      Command(cmd_usage, "Print this help")],
    [ "--help",  Command(cmd_usage, "Print this help")],
    [ "help",    Command(cmd_usage, "Print this help or that of a subcommand")],
    [ "init",    Command(cmd_init, "Initalize the present directory")],
    [ "add",     Command(cmd_add, "Add a new package")],
    [ "fetch",   Command(cmd_fetch, "Update or create a PKGBUILD from upstream")],
    [ "diff",    Command(cmd_diff, "Show differences since last verification")],
    [ "verify",  Command(cmd_verify, "Verify a pkgbuild")],
    [ "build",   Command(cmd_build, "Build the specified packages")],
]
commands_dict = { }
for k,v in commands:
    commands_dict[k] = v
program_name = re.sub('^.*/', '', sys.argv[0])

if len(sys.argv) <= 1:
    cmd_usage([])
else:
    try:
        c = find_command(sys.argv[1])
        c.callback(sys.argv[2:])
    except UserErrorMessage as e:
        e.print()
        sys.exit(1)
