
"""A git wrapper"""

from plaur.utils import *
import plaur

import subprocess
import os
import sys
import re
import subprocess

class Git:
    # create a wrapper objects to access the git repository
    # whose git root is at path
    def __init__(self, path):
        self.git_dir = path + "/.git"
        self.git_work_tree = path

    # call a git command without redirecting stderr or stdout
    def plain_call(self, *args):
        git_prefix = [ 'git',
                       '--work-tree=' + self.git_work_tree,
                       '--git-dir=' + self.git_dir,
        ]
        command = git_prefix + list(args)
        debug("Calling »%s«" % ' '.join(command))
        proc = subprocess.Popen(command)
        return proc.wait()

    # call a git subcommand, returning a tuple:
    # stdout,stderr,status
    def call(self, *args):
        git_prefix = [ 'git',
                       '--work-tree=' + self.git_work_tree,
                       '--git-dir=' + self.git_dir,
        ]
        command = git_prefix + list(args)
        debug("Calling »%s«" % ' '.join(command))
        proc = subprocess.Popen(command,
                                stdout=subprocess.PIPE,
                                stderr=subprocess.PIPE)
        status = proc.wait()
        stdout = proc.stdout.read().decode("utf-8")
        stderr = proc.stderr.read().decode("utf-8")
        return stdout, stderr, status

    # call a successful, i.e. raise an UserErrorMessage
    # if the command exists with a status other than 0.
    # returns stdout as a string
    def call_success(self, *args):
        out,err,status = self.call(*args)
        if status != 0:
            err = re.sub("[\r\n]*$", "", err)
            cmd = ' '.join(list(args))
            if err == '':
                raise UserErrorMessage("git %s failed with status %d." % (cmd, status))
            else:
                raise UserErrorMessage("git %s failed with status %s: %s" %
                                        (cmd, status, err))
        if err != '':
            # just pass stderr
            print("git: %s" % err, file=sys.stderr)
        return out

    # tells wether a certain file is tracked by git
    # filepath can either be absolute or relative to the CWD
    def is_tracked(self, filepath):
        _,_,status = self.call('ls-files', '--error-unmatch', filepath);
        return (status == 0);

    # tells whether the git is a plaur repository
    def is_plaur_repo(self):
        pf = os.path.join(self.git_work_tree, plaur.config.plaur_ini)
        return self.is_tracked(pf);

    # returns the CWD relative to the root of the working tree
    def prefix_of_cwd(self):
        return self.call_success('rev-parse', '--show-prefix').strip()

    # returns the absolute path of the working dir
    def work_tree(self):
        return self.git_work_tree

    # tells whether the git exists in the file system
    def exists(self):
        return os.path.isdir(self.git_work_tree) and os.path.isdir(self.git_dir)

    # exit with an error message if the git directory does not exist
    def assert_exists(self):
        if not os.path.isdir(self.git_dir):
            raise UserErrorMessage("Git directory %s does not exist" % self.git_dir)
        if not os.path.isdir(self.git_work_tree):
            raise UserErrorMessage("Git work tree %s does not exist" % self.git_work_tree)

    def HEAD(self):
        return self.call_success('rev-parse', 'HEAD').strip()

    # write the given lines to the .git/info/exclude
    # mark them as autogenerated and replace an existing autogenerated section
    def set_info_exclude(self, new_lines):
        self.assert_exists()
        exclude_file = os.path.join(self.git_dir, 'info')
        # 0. ensure files exist
        if not os.path.isdir(exclude_file):
            os.mkdir(exclude_file)
        exclude_file = os.path.join(exclude_file, 'exclude')
        # 1. read exclude file
        try:
            with open(exclude_file) as fh:
                exclude_lines = fh.read().splitlines()
        except FileNotFoundError as e:
            exclude_lines = []
        # 2. find autogenerated section
        begin_marker = '# BEGIN OF PLAUR GENERATED LINES - DO NOT EDIT'
        end_marker = '# END OF PLAUR GENERATED LINES'
        begin_indices = [i for i,x in enumerate(exclude_lines) if x == begin_marker]
        end_indices = [i for i,x in enumerate(exclude_lines) if x == end_marker]
        if len(begin_indices) >= 1:
            # lines before the first begin_marker
            prefix_lines = exclude_lines[0:begin_indices[0]]
            if len(end_indices) >= 1:
                # lines after the last end_marker
                suffix_lines = exclude_lines[end_indices[-1]+1:]
            else:
                # swallow everythin if there is no end_marker
                suffix_lines = []
        else:
            # if no begin_marker is found
            prefix_lines = exclude_lines
            suffix_lines = []
        # 3. replace section
        exclude_lines = \
            prefix_lines \
            + [begin_marker] \
            + new_lines \
            + [end_marker] \
            + suffix_lines
        # 4. write file
        with open(exclude_file, 'w') as fh:
            for l in exclude_lines:
                fh.write(l + '\n')


# return the absolute path of the git root for the current working directory
# without trailing slashes, or None, if cwd does not live in a git repository
def detect_git(cwd='.'):
    cmd = ['git', 'rev-parse', '--show-toplevel']
    proc = subprocess.Popen(cmd,
                            stdout=subprocess.PIPE,
                            stderr=subprocess.PIPE,
                            cwd=cwd)
    status = proc.wait()
    stdout = proc.stdout.read().decode("utf-8")
    stderr = proc.stderr.read().decode("utf-8")
    if status == 0 and stderr == '':
        return re.sub('[/\r\n]*$', '', stdout)
    else:
        return None;
